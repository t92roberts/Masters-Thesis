% Chapter Template

\chapter{Introduction} % Main chapter title

\label{ChapterIntroduction}

A key part of the Agile software development process is to create a sprint plan. An agile team combines their expected availability with their estimations of how large, complex and valuable their tasks are so that they can decide on which tasks will be delivered in the next sprint. The goal of this planning activity is to create a plan that delivers the most value to the customer within an iteration. While this might sound simple, even small projects can have many tasks to take into consideration and mismanaging this planning has the potential to create many operational risks. For example, taking on too many tasks increases the risk of non-delivery and can make the team seem inconsistent and unreliable. It also inevitably overloads the development team, something which could affect their job satisfaction. Mismanaging the business value delivered by a plan creates the risk that the team is viewed as not delivering useful software.

While an agile development team will intentionally keep the plan as short-term as possible (typically just one sprint), a longer-term plan known as a \emph{road map} can be useful for stakeholders to have an overview of the current state of the project. However, creating a road map comes with the important caveat that it can change frequently and dramatically after every sprint. Most commercial agile project management tools provide ways to create a product backlog and track the progress made on user stories using Kanban boards and burn-down charts. To create a plan, one can simply sort stories by business value from largest to smallest. More advanced tools can produce Gantt charts that map out a sequence of tasks according to the dependencies between them, but these generally only try to produce feasible plans. However, the aim of sprint planning is not just to produce a feasible plan but one that maximises the amount of value delivered to the customer.

Creating a road map can be modelled as an optimisation problem where a solution is a set of user stories assigned to sprints, the objective is to maximise the business value delivered by the road map, and constraints are used to represent dependencies between tasks and to prevent overloading a sprint with too much work. We refer to this problem as the Agile Sprint Planning Problem (ASPP). Complete methods have been used to find optimal solutions to the ASPP [\citet{golfarelli2012sprint}, \citet{golfarelli2013multi}]. However, it has been shown that as the size and complexity of the problem grows, the time taken to find the optimal solution grows exponentially. Results show that it can take tens of minutes to solve instances of the problem that are not uncommon in practice. Local search techniques are often used to find solutions to difficult optimisation problems that are 'good enough' by sacrificing the guarantee of optimality to gain an often substantial increase in speed.

\section{Contribution}

This thesis aims to answer the question: \emph{Can metaheuristics provide a better trade-off between computation time and solution quality for the ASPP than complete methods based on mathematical programming?} Therefore, this thesis contributes a model to the ASPP that is a set of user stories, sprints, and development constraints, and implements a metaheuristic that can find good solutions in a reasonable amount of time. In addition, it contributes a way to exploit characteristics specific to the ASPP to generate valuable solutions in the search.

This work is not to develop a user-friendly, graphical tool that will allow an agile team to create and maintain their product backlog and produce nicely-formatted reports. It will focus on writing code that combines local search techniques, running the code on test data sets, and comparing the results with an implementation that uses a complete algorithm.

\section{Summary of Results}

Combining a iterated local search with random restarts, simulated annealing and tabu search can find solutions that are within 1\% or 2\% of the optimal in significantly less time than using complete methods. It can be seen that when the size and complexity of the problem gets very large, the gap in value between the optimal and approximate begins to grow due to the exponential number of possible solutions. However, the number of iterations given to the local search is arbitrary and can be increased to a suitable amount that suits very large problems. This should make it possible to get within 1\% or 2\% of the optimal in large problems while still taking far less time than a complete algorithm.